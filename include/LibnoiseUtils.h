// noiseutils.h
//
// Copyright (C) 2003-2005 Jason Bevins
//
// This library is free software; you can redistribute it and/or modify it
// under the terms of the GNU Lesser General Public License as published by
// the Free Software Foundation; either version 2.1 of the License, or (at
// your option) any later version.
//
// This library is distributed in the hope that it will be useful, but WITHOUT
// ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
// FITNESS FOR A PARTICULAR PURPOSE.  See the GNU Lesser General Public
// License (COPYING.txt) for more details.
//
// You should have received a copy of the GNU Lesser General Public License
// along with this library; if not, write to the Free Software Foundation,
// Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
//
// The developer's email is jlbezigvins@gmzigail.com (for great email, take
// off every 'zig'.)
//

#ifndef NOISEUTILS_H
#define NOISEUTILS_H

#include <stdlib.h>
#include <string.h>
#include <string>
#include <functional>

#include <noise.h>

using namespace noise;

namespace noise
{

    namespace utils
    {

        /// @mainpage noiseutils
        ///
        /// @section intro Introduction
        ///
        /// This library contains useful classes for creating and rendering
        /// two-dimensional noise maps containing coherent noise that was
        /// generated from the libnoise library.  These classes are used to create
        /// procedural textures and terrain height maps.
        ///
        /// noiseutils is known to compile under Windows 2000 Service Pack 4
        /// (using Microsoft Visual C++ 5.0) and under Gentoo Linux 10.0 (using
        /// gcc 3.3.4).  It should be portable across all platforms that can
        /// compile libnoise.
        ///
        /// @section classes Classes
        ///
        /// This library contains the following classes:
        /// - A <i>noise map</i> class: This class implements a two-dimensional
        ///   array that stores floating-point values.  It's designed to store
        ///   coherent-noise values generated by a noise module.
        /// - Several <i>noise-map builder</i> classes: Each of these classes
        ///   fills a noise map with coherent-noise values generated by a noise
        ///   module.  While filling a noise map, it iterates the coordinates of
        ///   the input value along the surface of a specific mathematical object.
        ///   Each of these classes implements a different mathematical object,
        ///   such as a plane, a cylinder, or a sphere.
        /// - An <i>image</i> class: This class implements a two-dimensional array
        ///   that stores color values.
        /// - Several <i>image-renderer</i> classes: these classes render images
        ///   given the contents of a noise map.  Each of these classes renders an
        ///   image in a different way.
        ///
        /// @section contact Contact
        ///
        /// Contact jas for questions about noiseutils.  The spam-resistant email
        /// address is jlbezigvins@gmzigail.com (For great email, take off every
        /// <a href=http://www.planettribes.com/allyourbase/story.shtml>zig</a>.)

        /// The maximum width of a raster.
        const int RASTER_MAX_WIDTH = 32767;

        /// The maximum height of a raster.
        const int RASTER_MAX_HEIGHT = 32767;

#ifndef DOXYGEN_SHOULD_SKIP_THIS
        // The raster's stride length must be a multiple of this constant.
        const int RASTER_STRIDE_BOUNDARY = 4;
#endif


        /// Implements a noise map, a 2-dimensional array of floating-point
        /// values.
        ///
        /// A noise map is designed to store coherent-noise values generated by a
        /// noise module, although it can store values from any source.  A noise
        /// map is often used as a terrain height map or a grayscale texture.
        ///
        /// The size (width and height) of the noise map can be specified during
        /// object construction or at any other time.
        ///
        /// The GetValue() and SetValue() methods can be used to access individual
        /// values stored in the noise map.
        ///
        /// This class manages its own memory.  If you copy a noise map object
        /// into another noise map object, the original contents of the noise map
        /// object will be freed.
        ///
        /// If you specify a new size for the noise map and the new size is
        /// smaller than the current size, the allocated memory will not be
        /// NOISE_REALlocated.
        /// Call ReclaimMem() to reclaim the wasted memory.
        ///
        /// <b>Border Values</b>
        ///
        /// All of the values outside of the noise map are assumed to have a
        /// common value known as the <i>border value</i>.
        ///
        /// To set the border value, call the SetBorderValue() method.
        ///
        /// The GetValue() method returns the border value if the specified value
        /// lies outside of the noise map.
        ///
        /// <b>Internal Noise Map Structure</b>
        ///
        /// Internally, the values are organized into horizontal rows called @a
        /// slabs.  Slabs are ordered from bottom to top.
        ///
        /// Each slab contains a contiguous row of values in memory.  The values
        /// in a slab are organized left to right.
        ///
        /// The offset between the starting points of any two adjacent slabs is
        /// called the <i>stride amount</i>.  The stride amount is measured by
        /// the number of @a float values between these two starting points, not
        /// by the number of bytes.  For efficiency reasons, the stride is often a
        /// multiple of the machine word size.
        ///
        /// The GetSlabPtr() and GetConstSlabPtr() methods allow you to retrieve
        /// pointers to the slabs themselves.
        class NoiseMap
        {

            public:

                /// Constructor.
                ///
                /// Creates an empty noise map.
                NoiseMap();

                /// Constructor.
                ///
                /// @param width The width of the new noise map.
                /// @param height The height of the new noise map.
                ///
                /// @pre The width and height values are positive.
                /// @pre The width and height values do not exceed the maximum
                /// possible width and height for the noise map.
                ///
                /// @throw noise::ExceptionInvalidParam See the preconditions.
                /// @throw noise::ExceptionOutOfMemory Out of memory.
                ///
                /// Creates a noise map with uninitialized values.
                ///
                /// It is considered an error if the specified dimensions are not
                /// positive.
                NoiseMap(int width, int height);

                /// Copy constructor.
                ///
                /// @throw noise::ExceptionOutOfMemory Out of memory.
                NoiseMap(const NoiseMap& rhs);

                /// Destructor.
                ///
                /// Frees the allocated memory for the noise map.
                ~NoiseMap();

                /// Assignment operator.
                ///
                /// @throw noise::ExceptionOutOfMemory Out of memory.
                ///
                /// @returns Reference to self.
                ///
                /// Creates a copy of the noise map.
                NoiseMap& operator= (const NoiseMap& rhs);

                /// Clears the noise map to a specified value.
                ///
                /// @param value The value that all positions within the noise map are
                /// cleared to.
                void Clear(float value);

                /// Returns the value used for all positions outside of the noise map.
                ///
                /// @returns The value used for all positions outside of the noise
                /// map.
                ///
                /// All positions outside of the noise map are assumed to have a
                /// common value known as the <i>border value</i>.
                float GetBorderValue() const
                {
                    return m_borderValue;
                }

                /// Returns a const pointer to a slab.
                ///
                /// @returns A const pointer to a slab at the position (0, 0), or
                /// @a NULL if the noise map is empty.
                const float* GetConstSlabPtr() const
                {
                    return m_pNoiseMap;
                }

                /// Returns a const pointer to a slab at the specified row.
                ///
                /// @param row The row, or @a y coordinate.
                ///
                /// @returns A const pointer to a slab at the position ( 0, @a row ),
                /// or @a NULL if the noise map is empty.
                ///
                /// @pre The coordinates must exist within the bounds of the noise
                /// map.
                ///
                /// This method does not perform bounds checking so be careful when
                /// calling it.
                const float* GetConstSlabPtr(int row) const
                {
                    return GetConstSlabPtr(0, row);
                }

                /// Returns a const pointer to a slab at the specified position.
                ///
                /// @param x The x coordinate of the position.
                /// @param y The y coordinate of the position.
                ///
                /// @returns A const pointer to a slab at the position ( @a x, @a y ),
                /// or @a NULL if the noise map is empty.
                ///
                /// @pre The coordinates must exist within the bounds of the noise
                /// map.
                ///
                /// This method does not perform bounds checking so be careful when
                /// calling it.
                const float* GetConstSlabPtr(int x, int y) const
                {
                    return m_pNoiseMap + (size_t)x + (size_t)m_stride * (size_t)y;
                }

                /// Returns the height of the noise map.
                ///
                /// @returns The height of the noise map.
                int GetHeight() const
                {
                    return m_height;
                }

                /// Returns the amount of memory allocated for this noise map.
                ///
                /// @returns The amount of memory allocated for this noise map.
                ///
                /// This method returns the number of @a float values allocated.
                size_t GetMemUsed() const
                {
                    return m_memUsed;
                }

                /// Returns a pointer to a slab.
                ///
                /// @returns A pointer to a slab at the position (0, 0), or @a NULL if
                /// the noise map is empty.
                float* GetSlabPtr()
                {
                    return m_pNoiseMap;
                }

                /// Returns a pointer to a slab at the specified row.
                ///
                /// @param row The row, or @a y coordinate.
                ///
                /// @returns A pointer to a slab at the position ( 0, @a row ), or
                /// @a NULL if the noise map is empty.
                ///
                /// @pre The coordinates must exist within the bounds of the noise
                /// map.
                ///
                /// This method does not perform bounds checking so be careful when
                /// calling it.
                float* GetSlabPtr(int row)
                {
                    return GetSlabPtr(0, row);
                }

                /// Returns a pointer to a slab at the specified position.
                ///
                /// @param x The x coordinate of the position.
                /// @param y The y coordinate of the position.
                ///
                /// @returns A pointer to a slab at the position ( @a x, @a y ) or
                /// @a NULL if the noise map is empty.
                ///
                /// @pre The coordinates must exist within the bounds of the noise
                /// map.
                ///
                /// This method does not perform bounds checking so be careful when
                /// calling it.
                float* GetSlabPtr(int x, int y)
                {
                    return m_pNoiseMap + (size_t)x + (size_t)m_stride * (size_t)y;
                }

                /// Returns the stride amount of the noise map.
                ///
                /// @returns The stride amount of the noise map.
                ///
                /// - The <i>stride amount</i> is the offset between the starting
                ///   points of any two adjacent slabs in a noise map.
                /// - The stride amount is measured by the number of @a float values
                ///   between these two points, not by the number of bytes.
                int GetStride() const
                {
                    return m_stride;
                }

                /// Returns a value from the specified position in the noise map.
                ///
                /// @param x The x coordinate of the position.
                /// @param y The y coordinate of the position.
                ///
                /// @returns The value at that position.
                ///
                /// This method returns the border value if the coordinates exist
                /// outside of the noise map.
                float GetValue(int x, int y) const;

                /// Returns the width of the noise map.
                ///
                /// @returns The width of the noise map.
                int GetWidth() const
                {
                    return m_width;
                }

                /// Reallocates the noise map to recover wasted memory.
                ///
                /// @throw noise::ExceptionOutOfMemory Out of memory.  (Yes, this
                /// method can return an out-of-memory exception because two noise
                /// maps will temporarily exist in memory during this call.)
                ///
                /// The contents of the noise map is unaffected.
                void ReclaimMem();

                /// Sets the value to use for all positions outside of the noise map.
                ///
                /// @param borderValue The value to use for all positions outside of
                /// the noise map.
                ///
                /// All positions outside of the noise map are assumed to have a
                /// common value known as the <i>border value</i>.
                void SetBorderValue(float borderValue)
                {
                    m_borderValue = borderValue;
                }

                /// Sets the new size for the noise map.
                ///
                /// @param width The new width for the noise map.
                /// @param height The new height for the noise map.
                ///
                /// @pre The width and height values are positive.
                /// @pre The width and height values do not exceed the maximum
                /// possible width and height for the noise map.
                ///
                /// @throw noise::ExceptionInvalidParam See the preconditions.
                /// @throw noise::ExceptionOutOfMemory Out of memory.
                ///
                /// On exit, the contents of the noise map are undefined.
                ///
                /// If the @a OUT_OF_MEMORY exception occurs, this noise map object
                /// becomes empty.
                ///
                /// If the @a INVALID_PARAM exception occurs, the noise map is
                /// unmodified.
                void SetSize(int width, int height);

                /// Sets a value at a specified position in the noise map.
                ///
                /// @param x The x coordinate of the position.
                /// @param y The y coordinate of the position.
                /// @param value The value to set at the given position.
                ///
                /// This method does nothing if the noise map object is empty or the
                /// position is outside the bounds of the noise map.
                void SetValue(int x, int y, float value);

                /// Takes ownership of the buffer within the source noise map.
                ///
                /// @param source The source noise map.
                ///
                /// On exit, the source noise map object becomes empty.
                ///
                /// This method only moves the buffer pointer so this method is very
                /// quick.
                void TakeOwnership(NoiseMap& source);

            private:

                /// Returns the minimum amount of memory required to store a noise map
                /// of the specified size.
                ///
                /// @param width The width of the noise map.
                /// @param height The height of the noise map.
                ///
                /// @returns The minimum amount of memory required to store the noise
                /// map.
                ///
                /// The returned value is measured by the number of @a float values
                /// required to store the noise map, not by the number of bytes.
                size_t CalcMinMemUsage(int width, int height) const
                {
                    return CalcStride((size_t)width) * (size_t)height;
                }

                /// Calculates the stride amount for a noise map.
                ///
                /// @param width The width of the noise map.
                ///
                /// @returns The stride amount.
                ///
                /// - The <i>stride amount</i> is the offset between the starting
                ///   points of any two adjacent slabs in a noise map.
                /// - The stride amount is measured by the number of @a float values
                ///   between these two points, not by the number of bytes.
                size_t CalcStride(int width) const
                {
                    return (size_t)(((width + RASTER_STRIDE_BOUNDARY - 1)
                                     / RASTER_STRIDE_BOUNDARY) * RASTER_STRIDE_BOUNDARY);
                }

                /// Copies the contents of the buffer in the source noise map into
                /// this noise map.
                ///
                /// @param source The source noise map.
                ///
                /// @throw noise::ExceptionOutOfMemory Out of memory.
                ///
                /// This method NOISE_REALlocates the buffer in this noise map object if
                /// necessary.
                ///
                /// @warning This method calls the standard library function
                /// @a memcpy, which probably violates the DMCA because it can be used
                //. to make a bitwise copy of anything, like, say, a DVD.  Don't call
                /// this method if you live in the USA.
                void CopyNoiseMap(const NoiseMap& source);

                /// Resets the noise map object.
                ///
                /// This method is similar to the InitObj() method, except this method
                /// deletes the buffer in this noise map.
                void DeleteNoiseMapAndReset();

                /// Initializes the noise map object.
                ///
                /// @pre Must be called during object construction.
                /// @pre The noise map buffer must not exist.
                void InitObj();

                /// Value used for all positions outside of the noise map.
                float m_borderValue;

                /// The current height of the noise map.
                int m_height;

                /// The amount of memory allocated for this noise map.
                ///
                /// This value is equal to the number of @a float values allocated for
                /// the noise map, not the number of bytes.
                size_t m_memUsed;

                /// A pointer to the noise map buffer.
                float* m_pNoiseMap;

                /// The stride amount of the noise map.
                int m_stride;

                /// The current width of the noise map.
                int m_width;

        };


        /// Class for a noise-map builder
        ///
        /// A builder class builds a noise map by filling it with coherent-noise
        /// values generated from the surface of a two-dimensional mathematical
        /// object.  Each builder class defines a specific two-dimensional
        /// surface, such as a cylinder, sphere, or plane.
        ///
        /// A builder class describes these input values using a coordinate system
        /// applicable for the mathematical object (e.g., a latitude/longitude
        /// coordinate system for the spherical noise-map builder.)  It then
        /// "flattens" these coordinates onto a plane so that it can write the
        /// coherent-noise values into a two-dimensional noise map.
        ///
        /// <b>Building the Noise Map</b>
        ///
        /// To build the noise map, perform the following steps:
        /// - Pass the bounding coordinates to the SetBounds() method.
        /// - Pass the noise map size, in points, to the SetDestSize() method.
        /// - Pass a NoiseMap object to the SetDestNoiseMap() method.
        /// - Pass a noise module (derived from noise::module::Module) to the
        ///   SetSourceModule() method.
        /// - Call the Build() method.
        ///
        /// You may also pass a callback function to the SetCallback() method.
        /// The Build() method calls this callback function each time it fills a
        /// row of the noise map with coherent-noise values.  This callback
        /// function has a single integer parameter that contains a count of the
        /// rows that have been completed.  It returns void.
        ///
        /// Note that SetBounds() is not defined in the abstract base class; it is
        /// only defined in the derived classes.  This is because each model uses
        /// a different coordinate system.
        class NoiseMapBuilder
        {

            public:

                /// Constructor.
				NoiseMapBuilder() {};

                /// Builds the noise map.
                ///
                /// @pre SetBounds() was previously called.
                /// @pre SetDestNoiseMap() was previously called.
                /// @pre SetSourceModule() was previously called.
                /// @pre The width and height values specified by SetDestSize() are
                /// positive.
                /// @pre The width and height values specified by SetDestSize() do not
                /// exceed the maximum possible width and height for the noise map.
                ///
                /// @post The original contents of the destination noise map is
                /// destroyed.
                ///
                /// @throw noise::ExceptionInvalidParam See the preconditions.
                /// @throw noise::ExceptionOutOfMemory Out of memory.
                ///
                /// If this method is successful, the destination noise map contains
                /// the coherent-noise values from the noise module specified by
                /// SetSourceModule().
                void Build();

				void Build(std::function<void(int, int, float)> fCallback);


                /// Returns the height of the destination noise map.
                ///
                /// @returns The height of the destination noise map, in points.
                ///
                /// This object does not change the height in the destination noise
                /// map object until the Build() method is called.
                NOISE_REAL GetDestHeight() const
                {
                    return (NOISE_REAL)m_destHeight;
                }

                /// Returns the width of the destination noise map.
                ///
                /// @returns The width of the destination noise map, in points.
                ///
                /// This object does not change the height in the destination noise
                /// map object until the Build() method is called.
                NOISE_REAL GetDestWidth() const
                {
                    return (NOISE_REAL)m_destWidth;
                }


                /// Sets the destination noise map.
                ///
                /// @param destNoiseMap The destination noise map.
                ///
                /// The destination noise map will contain the coherent-noise values
                /// from this noise map after a successful call to the Build() method.
                ///
                /// The destination noise map must exist throughout the lifetime of
                /// this object unless another noise map replaces that noise map.
                void SetDestNoiseMap(NoiseMap& destNoiseMap)
                {
                    m_pDestNoiseMap = &destNoiseMap;
                }

                /// Sets the source module.
                ///
                /// @param sourceModule The source module.
                ///
                /// This object fills in a noise map with the coherent-noise values
                /// from this source module.
                ///
                /// The source module must exist throughout the lifetime of this
                /// object unless another noise module replaces that noise module.
                void SetSourceModule(const module::Module& sourceModule)
                {
                    m_pSourceModule = &sourceModule;
                }

                /// Sets the size of the destination noise map.
                ///
                /// @param destWidth The width of the destination noise map, in
                /// points.
                /// @param destHeight The height of the destination noise map, in
                /// points.
                ///
                /// This method does not change the size of the destination noise map
                /// until the Build() method is called.
                void SetDestSize(int destWidth, int destHeight)
                {
                    m_destWidth  = destWidth ;
                    m_destHeight = destHeight;
                }

				/// Enables or disables seamless tiling.
				///
				/// @param enable A flag that enables or disables seamless tiling.
				///
				/// Enabling seamless tiling builds a noise map with no seams at the
				/// edges.  This allows the noise map to be tileable.
				void EnableSeamless(bool enable = true)
				{
					m_isSeamlessEnabled = enable;
				}

				/// Returns the lower x boundary of the planar noise map.
				///
				/// @returns The lower x boundary of the planar noise map, in units.
				NOISE_REAL GetLowerXBound() const
				{
					return m_lowerXBound;
				}

				/// Returns the lower z boundary of the planar noise map.
				///
				/// @returns The lower z boundary of the noise map, in units.
				NOISE_REAL GetLowerZBound() const
				{
					return m_lowerZBound;
				}

				/// Returns the upper x boundary of the planar noise map.
				///
				/// @returns The upper x boundary of the noise map, in units.
				NOISE_REAL GetUpperXBound() const
				{
					return m_upperXBound;
				}

				/// Returns the upper z boundary of the planar noise map.
				///
				/// @returns The upper z boundary of the noise map, in units.
				NOISE_REAL GetUpperZBound() const
				{
					return m_upperZBound;
				}

				/// Determines if seamless tiling is enabled.
				///
				/// @returns
				/// - @a true if seamless tiling is enabled.
				/// - @a false if seamless tiling is disabled.
				///
				/// Enabling seamless tiling builds a noise map with no seams at the
				/// edges.  This allows the noise map to be tileable.
				bool IsSeamlessEnabled() const
				{
					return m_isSeamlessEnabled;
				}

				/// Sets the boundaries of the planar noise map.
				///
				/// @param lowerXBound The lower x boundary of the noise map, in
				/// units.
				/// @param upperXBound The upper x boundary of the noise map, in
				/// units.
				/// @param lowerZBound The lower z boundary of the noise map, in
				/// units.
				/// @param upperZBound The upper z boundary of the noise map, in
				/// units.
				///
				/// @pre The lower x boundary is less than the upper x boundary.
				/// @pre The lower z boundary is less than the upper z boundary.
				///
				/// @throw noise::ExceptionInvalidParam See the preconditions.
				void SetBounds(NOISE_REAL lowerXBound, NOISE_REAL upperXBound,
					NOISE_REAL lowerZBound, NOISE_REAL upperZBound)
				{
					if (lowerXBound >= upperXBound
						|| lowerZBound >= upperZBound)
					{
						throw noise::ExceptionInvalidParam();
					}

					m_lowerXBound = lowerXBound;
					m_upperXBound = upperXBound;
					m_lowerZBound = lowerZBound;
					m_upperZBound = upperZBound;
				}


            protected:


                /// Height of the destination noise map, in points.
                int m_destHeight = 0;

                /// Width of the destination noise map, in points.
                int m_destWidth = 0;

                /// Destination noise map that will contain the coherent-noise values.
                NoiseMap* m_pDestNoiseMap = nullptr;

                /// Source noise module that will generate the coherent-noise values.
                const module::Module* m_pSourceModule = nullptr;

				/// A flag specifying whether seamless tiling is enabled.
				bool m_isSeamlessEnabled = false;

				/// Lower x boundary of the planar noise map, in units.
				NOISE_REAL m_lowerXBound = 0.0;

				/// Lower z boundary of the planar noise map, in units.
				NOISE_REAL m_lowerZBound = 0.0;

				/// Upper x boundary of the planar noise map, in units.
				NOISE_REAL m_upperXBound = 0.0;

				/// Upper z boundary of the planar noise map, in units.
				NOISE_REAL m_upperZBound = 0.0;

        };




    }

}

#endif
